{"./":{"url":"./","title":"README","keywords":"","body":"RVBOOK 文档 成员：江芳、程晓宇、周喆、孙杨 Git操作 0、获取帮助 git --help 1、克隆到本地 git clone https://github.com/zznjupt/RVBOOK.git 2、上传到远程仓库 git pull //确保最新版本 git add . git commit -m\"XXXX\" git push "},"TrustCom2022/meeting1.html":{"url":"TrustCom2022/meeting1.html","title":"学习框架和短期要求","keywords":"","body":"6.2日小会讨论 https://docs.qq.com/doc/DRENqbWZCTVVWcmF6?u=c0e3e6d7852c4a95b8460bddc96738c8&&_t=1654675092605 学习框架 目前确定了研究目标CPU为：XUANTIE-C910 之前讨论了用实验室服务器作为仿真平台，但是最好个人PC都可以把工具链安装编译和进行实验，因此需要做的事： 仿真工具链以及工具链使用方法：需要编写说明文档，说明文档上传至本网页 自己的环境和依赖项 标注工具链下载出处和版本号 步骤完整，流程清晰 整理所有遇到的问题，如果解决，请给出解决方法，未解决问题大家一起想办法 上传方法 将本文档git pull下来之后在 TrustCom2022 文件夹下新建.md文件，写好后push上即可，网页端不会及时更新需要我这边编译一下，我会在每天的不固定时间编译上传 要明确自己在做什么事情，每件事请最好有独立的文档 Good luck！ 6.13日与童老师对话要点 跟童老师说了本周很忙，下周有期末考试，下周组会不用去 调研一下《Xuantie-910: A Commercial Multi-Core 12-Stage Pipeline Out-of-Order 64-bit High Performance RISC-V Processor with Vector Extension》作者的身份背景，包括但不局限于学校学历，职业等 Chen Chen, Xiaoyan Xiang, Chang Liu, Yunhai Shang, Ren Guo, Dongqi Liu, Yimin Lu, Ziyi Hao, Jiahui Luo, Zhijian Chen, Chunqiang Li, Yu Pu, Jianyi Meng*, Xiaolang Yan, Yuan Xie and Xiaoning Qi. The T-Head Division, Alibaba Cloud Email: jianyi.mjy@alibaba-inc.com 检索调研复旦微的关于C910或者微架构方面的硕士论文 继续各自的仿真实验 尽快安排与王老师下一次见面 思考有什么需要购买的实验器材 6.23日与王老师对话要点 尽量赶7.1的ddl 找出玄铁C910中的安全机制，特别关注分支预测部分是否有 C910中的安全机制是否对攻击有影响 测试安全机制对性能的影响（有无安全机制，得出跑分结果） 将C910中的安全机制放到Boom中，查看是否能提高相应安全性 "},"TrustCom2022/cxydebug.html":{"url":"TrustCom2022/cxydebug.html","title":"程晓宇Debug","keywords":"","body":"搭建qemu验证环境 参考的是c9xx linux-5.10 的 readme.txt -> Quick Start for qemu run 章节: https://github.com/c-sky/buildroot/releases/tag/v1.0.10.1 调试日记 缺失库\\ 在运行这一行指令时 LD_LIBRARY_PATH=./host/lib ./host/csky-qemu/bin/qemu-system-riscv64 -M virt q-kernel fw_jump.elf -device loader,file=Image,addr=0x80200000 -append \"rootwait root=/dev/vda ro\" -drive file=rootfs.ext2,format=raw,id=hd0 -device virtio-blk-device,drive=hd0 -nographic -smp 1\\ 会出现如下报错 文档里给的是基于Ubuntu16.04的，我使用的是Ubuntu20.04所以在安装前要查看缺失的库； 解决方案 从https://ftp.gnu.org/gnu/nettle/ 下载源码（我下载的是3.2版本的可以用） 执行 ./configure && make -j 4 直接将编译出来的动态链接库libnettle.so 重命名为之前not found的 libnettle.so.6 后移动到usr/lib "},"TrustCom2022/fangjDebug.html":{"url":"TrustCom2022/fangjDebug.html","title":"江芳debug","keywords":"","body":"2022-06-15 1.qemu-riscv64运行spectre V1代码时出现：Illegal instruction 通过gdb调试发现，问题在于src/crt.S:52，相应的指令为csrs mstatus, t0 "},"TrustCom2022/zz.html":{"url":"TrustCom2022/zz.html","title":"Verilator仿真-周喆","keywords":"","body":"玄铁C910 RTL -- verilator仿真记录 环境搭建 玄铁C910 IP 包开源在github： git clone https://github.com/T-head-Semi/openc910.git 玄铁C910 IP 包由以下两部分组成： C910源码包，包含固定功能配置的 C910 RTL 代码； C910 Smart平台，提供了 C910 的参考集成设计，仿真环境和测试用例等，帮助熟悉 C910的功能和使用方法，并辅助 C910 的集成工作 该 IP 包所需要的环境在玄铁C910手册里： 玄铁C910IP中的 perl 脚本依赖 perl 5.10.1 或以上版本； Make 版本为 3.8.1； EDA仿真工具：Icarus Verilog（iverilog）10.2，Synopsys VCS 2019.06及以上版本，或者Cadence Xcelium19.09及以上版本；带UPF的低功耗仿真仅在 VCS 2020.12版本上进行了测试 Smart 平台编译测试用例依赖平头哥玄铁处理器 RISC-V工具链 2.0.3 及以上版本 根据说明，我们方便使用的开源仿真工具只有iverilog，复旦微的研究生在仓库main分支上上传了支持verilator（4.215 or later）仿真的脚本，因此本次环境搭建将使用verilator仿真器 verilator安装 本实验机器OS：ubuntu18.04 LTS 安装流程从官网上贴了下来： # Prerequisites: #sudo apt-get install git perl python3 make autoconf g++ flex bison ccache #sudo apt-get install libgoogle-perftools-dev numactl perl-doc #sudo apt-get install libfl2 # Ubuntu only (ignore if gives error) #sudo apt-get install libfl-dev # Ubuntu only (ignore if gives error) #sudo apt-get install zlibc zlib1g zlib1g-dev # Ubuntu only (ignore if gives error) git clone https://github.com/verilator/verilator # Only first time # Every time you need to build: unsetenv VERILATOR_ROOT # For csh; ignore error if on bash unset VERILATOR_ROOT # For bash cd verilator git pull # Make sure git repository is up-to-date git tag # See what versions exist #git checkout master # Use development branch (e.g. recent bug fixes) #git checkout stable # Use most recent stable release #git checkout v{version} # Switch to specified release version autoconf # Create ./configure script ./configure # Configure and create Makefile make -j `nproc` # Build Verilator itself (if error, try just 'make') sudo make install 玄铁处理器RISC-V工具链下载 https://occ.t-head.cn/community/download?id=3948120165480468480 我下载的版本是 Xuantie-900-gcc-elf-newlib-x86_64-V2.4.0-20220428.tar.gz 仿真流程 首先修改openc910 project下的两个用于部署环境的.csh文件修改为.sh文件： openc910/C910_RTL_FACTORY/setup/setup.csh #!/bin/csh set pattern = \"\\/setup\"`echo '$'` setenv CODE_BASE_PATH `pwd | perl -pe \"s/$pattern//\"` echo \"Root of code base has been specified as:\\n $CODE_BASE_PATH\" ->openc910/C910_RTL_FACTORY/setup/setup.sh #!/usr/bin/bash pattern=\"\\/setup\"`echo '$'` export CODE_BASE_PATH `pwd | perl -pe \"s/$pattern//\"` echo \"Root of code base has been specified as:\\n $CODE_BASE_PATH\" openc910/smart_run/setup/example_setup.csh #!/bin/csh setenv TOOL_EXTENSION /tools/riscv/riscv64-elf-x86_64/bin echo 'Toolchain path($TOOL_EXTENSION):' echo \" $TOOL_EXTENSION\" ->openc910/smart_run/setup/example_setup.sh #!/usr/bin/bash export TOOL_EXTENSION=/home/dios/XUANTIE/Xuantie-900-gcc-elf-newlib-x86_64-V2.4.0-20220428/Xuantie-900-gcc-elf-newlib-x86_64-V2.4.0/bin echo 'Toolchain path($TOOL_EXTENSION):' echo \" $TOOL_EXTENSION\" 接着，执行两个setup脚本，注意需要严格按照下面步骤执行，因为启动脚本的位置影响结果 cd openc910/C910_RTL_FACTORY source setup/setup.sh cd ../smart_run source setup/example_setup.sh 如果执行sh脚本报错如下： :Syntax error: Bad fd number 可能是sh链接到了dash，因此需要检查链接情况： ls -l /bin/sh 如果得到的结果是 /bin/sh -> dash 那么执行以下命令即可 sudo mv /bin/sh /bin/sh.orig sudo ln -s /bin/bash /bin/sh 再次检查应该得到正确的结果 /bin/sh -> /bin/bash 接着，在/smart_run下创建/work目录 mkdir work 然后即可进行仿真工作，本次实验选取的备选CASE为hello_world make cleanVerilator make compile SIM=verilator make buildVerilator make buildcase CASE=hello_world make runVerilator 但是每次运行buildVerilator的时候总会运行过程中死机重启，初步认为是内存不够的原因，分配了26G内存依旧存在这个问题，之后在服务器上跑试试看 应该就是内存问题或者是虚拟机性能问题，在服务器上成功helloworld "},"TrustCom2022/Qemu.html":{"url":"TrustCom2022/Qemu.html","title":"江芳Qemu","keywords":"","body":"1、编译运行：Hello World 1.编写代码 #include int main(void) { printf(\"Hello World!\\n\"); return 0; } 2.生成可执行文件 使用riscv的gcc交叉编译器在x86生成riscv的可执行文件 需要添加 -static编译选项。表示使用静态链接 riscv64-linux-gnu-gcc -static hello.c -o hello 3.执行 qemu-system-riscv64 对应system mode qemu-riscv64 对应user mode 这里应该使用user模式 qemu-riscv64 hello # 2、系统模式下添加共享文件夹 ①主机中创建共享文件夹 mkdir /home/jiangfang/share ②启动时添加如下两行参数： path为主机中共享文件夹的位置 -fsdev local,security_model=passthrough,id=fsdev0,path=/home/jiangfang/share \\ -device virtio-9p-device,id=fs0,fsdev=fsdev0,mount_tag=hostshare ③qemu中创建文件夹 mkdir /tmp/share ④挂载 mount -t 9p -o trans=virtio,version=9p2000.L hostshare /tmp/share/ "},"TrustCom2022/xuantieC910.html":{"url":"TrustCom2022/xuantieC910.html","title":"江芳xuantieC910","keywords":"","body":"资料 平头哥快速上手文档 BuildRoot发行版（重要！） T-HEAD CPU调试技巧(GDB) XuanTie QEMU 用户手册 1、下载C910 Qemu 打开xuantie发行版页面： https://github.com/c-sky/buildroot/releases C910对应的版本是： c9xx linux-5.10 阅读readme.txt,这是官方给的使用手册。 新建一个工作目录，如xuantie，下面所有操作都将在该文件夹下进行。 参考 readme.txt -> Quick Start for qemu run 章节，并运行相应的代码。你将获得： fw_jump.elf host Image rootfs.ext2 相关工具（如qemu、gcc、gdb）等在host中。具体路径需要你自己探索。你需要将该路径加入到PATH中，这样在使用时就不需要写绝对路径了。 2、添加共享文件夹 请参考Qemu相关章节，为主机和qemu模拟出的系统，添加共享文件夹。 需要在qemu中执行的文件，请放入共享文件夹中。 3、启动qemu，运行代码 在xuantie文件夹下，运行：LD_LIBRARY_PATH=./host/lib \\ qemu-system-riscv64 \\ -M virt \\ -cpu c910 \\ -kernel fw_jump.elf \\ -device loader,file=Image,addr=0x80200000 -append \"rootwait root=/dev/vda ro\" \\ -drive file=rootfs.ext2,format=raw,id=hd0 -device virtio-blk-device,drive=hd0 \\ -fsdev local,security_model=passthrough,id=fsdev0,path=/home/jiangfang/share \\ -device virtio-9p-device,id=fs0,fsdev=fsdev0,mount_tag=hostshare \\ -nographic \\ -smp 1 输入用户名\"root\" 挂载共享目录 mount -t 9p -o trans=virtio,version=9p2000.L hostshare /tmp/share/ 进入共享文件夹 cd /tmp/share 执行 ./hello "},"TrustCom2022/spectre-attack.html":{"url":"TrustCom2022/spectre-attack.html","title":"幽灵攻击","keywords":"","body":"需要解决的问题 1、Cache冲刷问题 玄铁C910采用物理地址索引，物理地址标记(PIPT)。因此首先需要将虚拟地址转换为物理地址，再根据物理地址去访问Cache。代码需要改动 2、分支预测器训练 一、Xuantie C910 L1 Dcache 大小为64KB，2 路组相联，缓存行大小为64B； 物理地址索引，物理地址标记(PIPT)； 写策略支持写回-写分配模式和写回-写不分配模式； 采用先进先出的替换策略； 支持对整个数据高速缓存的无效和清除操作，支持对单条缓存行的无效和清除操作；（用户模式下不可用） 支持数据预取 二、Cache冲刷策略概述 RISC-V CPU的指令集还不支持对cache line的直接操作（x86有clflush），需要其他方法来实现与clflush操作相同的效果，比如我们可以通过往cache中的指定位置加载新的垃圾内容，对原有的本来想刷新的内容进行覆盖(本质上是cache中的tag改变)，从而变相地实现对cache指定地址的flush等效操作。 举个极端的例子，如果你知道整个Cache有64KB，那么你加载64KB大小的随机内存数据（垃圾数据）到一个数组中，则这些数据就会被同时加载到data Cache中，因为Cache只有64KB大小，这时Cache中原本的所有数据会被冲走，我们采用的方法类似，但只flush我们关心的cache行，而不是整个cache。 Cache查找的策略是，根据set（idx)位锁定所在行，并于该行中的n路（Ways)的tag进行比较。如果有相同的，则表示cache hit。否则Cache miss。 因此，只需要访问相同idx，但是不同tag地址的数据就可以将原有的cache line驱逐出去。 /* ---------------------------------- * | Cache address | * ---------------------------------- * | tag | idx | offset | * ---------------------------------- * | 63 15 | 14 6 | 5 0 | * ---------------------------------- */ 三、代码 理解可能存在有误的情况，请及时指正。 1、宏定义 修改inc/cache.h中的相关宏定义，以适用于Xuantie C910。 已知L1 Dcache的参数如下： 参数 术语 数值 缓存行大小 Cache line 64B 缓存行数目 Sets 512 路数 Ways 2 //cache line 是cache和主存之间传输的最小单位 #define L1_BLOCK_SZ_BYTES 64 #define L1_BLOCK_BITS 6 // note: this is log2Ceil(L1_BLOCK_SZ_BYTES) //512行 cache line #define L1_SETS 512 #define L1_SET_BITS 9 // note: this is log2Ceil(L1_SETS) //路（Ways） #define L1_WAYS 2 2、变量解析 请对照具体源码 变量 含义 dummyMem 存放脏数据的数组 numSetsClear 需要清除的缓存行的个数 alignedMem dummyMeme[L1_SIZE_BYTES]处地址的tag值 setOffset set值（idx) wayOffset 参考网址 RISC-V CPU侧信道攻击原理与实践（4）-- Cache测量 "},"CIRED/outline.html":{"url":"CIRED/outline.html","title":"论文大纲","keywords":"","body":"CIRED论文大纲 0、切入点 聚焦于电力主控芯片？配电融合终端？ 摘要 泛在电力物联网要求电力系统从原来的集中监控模式转变为分布式、物联网化的泛在模式。配电物联网终端需要高性能、低功耗（、安全性）的微处理器（MCU）作为支撑。而RISC-V指令集因其精简、开源、支持自定义扩展等优势，在配电融合终端中具有广泛的使用前景。本文针对基于RISC-V指令集架构的融合终端，研究和探索MCU级的攻击和防御策略对其在安全、性能、应用支持等方面的影响。该研究采用软件仿真方法结合FPGA原型验证进行，为面向配电终端应用的MCU架构设计提供新方案。 关键词：电力终端、数据保护、RISC-V、攻击与防御 1.引言 介绍电力融合终端与芯片安全的关系，引入对芯片安全的讨论； 电力网络系统中的安全防护要防止信息数据被非授权访问者的窃取、篡改和破坏。利用幽灵攻击读取终端的秘密数据对电力网络系统的安全造成威胁。 BOOM高性能乱序处理器——>可用于电力行业？ 通用芯片可满足电力领域当前的需求 BOOM开源、高性能、低功耗 1.1 配电终端安全防护现状及风险 1.2 开源 RISC-V 处理器 BOOM 1.3 幽灵与熔断 2.Speculative attack replication 2.1 Implementation Details 2.2 Bounds Check Bypass Attack（V1） 2.3 Branch Target Injection Attack（V2） 3.Result and analysis of XXX 3.1 Experimental Setup and Results 3.2 Experimental analysis on hardware platforms 3.1 安全性分析security analysis 3.2 性能开销评估 4.Mitigation Options 芯片层级防御方法总结 通过提出幽灵攻击防御策略 增强RISC-V安全性 能否提出针对电力芯片安全的轻量级的缓解措施 5.相关工作 电网安全保护措施，从不同层的措施—》芯片层、终端层等 RISC-V架构安全 6.总结 6.1 主要贡献 基于RISC-V架构用于电网保护的研究工作目前较少 进行了电力芯片常见攻击及防御方法的验证 参考文献 参考资料 电力主控芯片有了“中国芯” RISC-V’s Role in Securing IoT-Connected Devices 基于RISC-V的MCU内核TaiShan200 Spectre and Meltdown explained: A comprehensive guide for professionals "},"CIRED/dataprotect.html":{"url":"CIRED/dataprotect.html","title":"电网数据保护调研","keywords":"","body":"电网数据保护调研 电力系统中各种电压的变电所及输配电线路组成的整体，称为电力网，简称电网。它包含变电、输电、配电三个单元。电力网的任务是输送与分配电能，改变电压。 电网按其在电力系统中的作用不同，分为输电网和配电网。 输电网是以高压甚至超高压电将发电厂、变电所或变电所之间连接起来的送电网络，所以又称为电力网中的主网架。 配电网是承担分配的任务，通过配电设施就地分配或者按电压逐级分配给各类用户。 SG（智能电网，smart grid）涉及的两个关键设备[1]^{[1]}​[1]​​： （1） 智能/高级电表(SMs)，装备房屋，工厂、机构 等。它们记录能源消耗数据和其他信息，为计费或管理做 好准备。它们可以根据请求或针对某些事件对实用程序进 行定期报告，也可响应实用程序的请求(例如，软件更新、实时定价、负载脱落、能量切断等)，这得益于它们的双向通信能力。它们可以选择发挥当家能源管理系统的角色，通过控制/管理房子内智能设备 （冰箱、烤箱、空调、电动车等)来监控能源消耗。 （2）先进的计量基础设施(AMI )，负责收集、分析、 存储和提供SMS发送给适当授权方的计量数据(例如，能源提供商、公用事业机构、SG操作员、电表数据管理服务等)，以便它们可以进行(计费，停机管理，需求预测 等)。AMI 还负责向 SMS 中的授权方发送请求、命令，定价信息和软件更新。 相关问题： 隐私问题： 智能电表和智能家电在住宅中的应用，比能源消耗更能说明问题。它们生成的细粒度数据可能会损害终端用户的隐私，比如泄露用户的起床睡觉、 吃饭时间等，是否在家、在度假等等[1]^{[1]}​[1]​​。在智能电力系统进行配置的过程当中，需要对用户信息进行提取分析和信息传递。一些不法分子通过攻击电网系统或终端非法获取用户用电信息，出现了数据转卖或窃电情况，严重危害了电网系统的安全性与稳定性[2]^{[2]}​[2]​​。 数据安全需求[3]^{[3]}​[3]​​： 数据完整性，要确保(接收到的)数据没有以未经授权的方式进行修改。例如，智能仪表需要保证软件更新的完整性，除了源程序。数据机密性，确保数据(存储或传输)仅对预期的接收者可访问。例如，最终用户的消耗只需要SG的运营商和能源供应商知道。 用户隐私，保证与用户(能源消费终端用户)相关的任何数据——brut、推断或计算数据 ——未经其明确批准不能获得，且仅用于预期目的。例如，用于账单目的的能源消耗数据不能用于其他目的。 配电终端： 配电自动化系统属于电力系统中的重要控制系统， 它在提高配电网供电可靠性与供电质量、提升配电网精益化管理水平等方面发挥重要作用；配电终端是配电自动化系统的重要组成部分，承担着配电系统的数据采集和控制指令的执行任务[4]^{[4]}​[4]​​。 智能配电网是智能电网重要的组成部分，对智能电网的发展起着举足轻重的作用。智能配电网(Smart Distribution Grid ,SDG)，是未来配电网的发展方向，是一个由电力设备和通信设备组成的全新配电系统。智能配电网对于新能源新设备(如分布式能源与储能设备)的接入具有很好的兼容性，配电网与消费者之间的互动能力显著增强。智能配电网相对于传统配电网有更精细化的管理，使的整个智能电网能够更好的适应社会发展。智能配电网在技术上融合了电力电子技术、计算机网络通信技术和传感器技术，具有高集成、高互动、高自愈、高优化的特点，可以实现配电网信息业务流与消费信息流的高效双向交互和整合。此外，智能配电网的高自动化使得生产者可以对整配电网进行灵活的调控，可以全方面的提升电网的电能质量，并能使配电网的各个子系统融合成一个有机的整体[5]^{[5]}​[5]​​。 相关问题： 当前配电终端设计上，开发商注重产品的功能，较少考虑自身的信息安全防护，此外，配电终端具有点多、面广、户外运行、容易接触等特点，致使配电终端系统极易成为黑客入侵的目标，甚至工程维护人员在维护时也可能有意或无意地引入间谍或后门病毒，为背后的攻击者进一步入侵配电系统做铺垫准备工作，因此提升配电终端自身的安全防护和入侵检测能力是对新型高级持续性威胁（ＡＰＴ）的必要的应对措施[4]^{[4]}​[4]​​。 配电终端存在自身信息安全防护薄弱、攻击监测手段缺乏等问题； 随着智能配电网的快速发展，现代通信技术与计算机网络技术被广泛的应用于智能配电网中，电网与用户之间可以通过双向通信的数字网络来进行实时的信息交互。这时直接暴露在用户面前的终端（如智能电表)，将最可能成为攻击的对象。 配电终端可信安全防护方案研究[4]^{[4]}​[4]​​ 这篇论文提出了配电终端可信安全防护方案，即在配电终端上引入了可信计算的理念，采用可信硬件芯片作为引导起点，进而建立从操作系统内核、核心库到应用程序等一系列的度量与验证的启动过程，以确保在终端上运行的程序都是合法程序，以提升配电终端自身的安全防护能力。 同时在配电终端运行过程中，对文件系统的完整性进行周期检测，对运行进程的文件修改行为、网络请求行为、重要资源访问行为进行监测，监测数据用于进行动态风险辨识，以便发现病毒入侵和违规访问等安全事件，一方面保护配电系统的运行安全，也增强了配电系统对入侵的预警能力。 参考文献： 陈亮,杨晓勇.基于物联网的智能电网安全问题和挑战[J].机电工程技术,2018,47(12):161-163+176. 程晓岩,丛鹏,赵子鉴.电力系统计算机网络信息安全的防护分析[J].价值工程,2020,39(09):250-251.DOI:10.14018/j.cnki.cn13-1085/n.2020.09.106. 曹玮润,戴媛媛,周永博.计算机网络信息安全在电力系统的防护[J].长江信息通信,2021,34(01):171-173. 常方圆,李二霞,亢超群,吕春利,王靖夫,林璟锵.配电终端可信安全防护方案研究[J].计算机应用研究,2020,37(S2):256-259. 戴熙昌. 智能配电网数据传输安全研究[D].华东交通大学,2015 "},"CIRED/implementation.html":{"url":"CIRED/implementation.html","title":"实验部分内容","keywords":"","body":""},"ysyx/riscvCpu/SingleCycleCore.html":{"url":"ysyx/riscvCpu/SingleCycleCore.html","title":"单周期非流水CPU","keywords":"","body":"单周期CPU设计 参考内容 The RISC-V Instruction Set Manual (Volume I） 《CPU设计实战》第四章P75-P92 《计算机组成与设计 硬件软件接口（第五版）》第四章4.1-4.4小节 NutShell源码 Trigger：chisel写的4级流水线顺序单发射处理器核 在次之前，你需要对RISC-V指令集有个简单的了解。本文的单周期处理器支持RISCV64IM指令。 1、译码模块 指令集 这里仿照果壳Nutshell的译码方式。通过BitPat匹配指令，同时每一条指令都绑定了具体的指令类型、操作单元以及具体的操作。 //RV64MInstr def MULW = BitPat(\"b0000001_?????_?????_000_?????_0111011\") def DIVW = BitPat(\"b0000001_?????_?????_100_?????_0111011\") def DIVUW = BitPat(\"b0000001_?????_?????_101_?????_0111011\") def REMW = BitPat(\"b0000001_?????_?????_110_?????_0111011\") def REMUW = BitPat(\"b0000001_?????_?????_111_?????_0111011\") val RV64M_Table = Array( MULW -> List(InstrR, FuType.mdu, MDUOpType.mulw), DIVW -> List(InstrR, FuType.mdu, MDUOpType.divw), DIVUW -> List(InstrR, FuType.mdu, MDUOpType.divuw), REMW -> List(InstrR, FuType.mdu, MDUOpType.remw), REMUW -> List(InstrR, FuType.mdu, MDUOpType.remuw) ) 在译码单元，通过以下命令就可以获取指令的类型和操作类型。 val decodeList = ListLookup(instr, Instructions.DecodeDefault, Instructions.DecodeTable) val instrType = decodeList(0) val fuType = decodeList(1) val fuOpType = decodeList(2) 控制信号 译码模块根据instrType、fuType、fuOpType生成以下控制信号： 控制信号 含义 instrType 指令类型（I、R、S、B、U、J） fuType 操作单元（ALU、LSU、MDU等） fuOpType 具体操作（如add、sub、jal等） alu1Type ALU操作数1类型，0：寄存器，1：PC alu2Type ALU操作数2类型，0：寄存器，1：imm rfSrc1 源寄存器rs rfSrc2 源寄存器rt rfWen 寄存器堆写使能 rfDest 目的寄存器 imm 立即数 sel_rf_res 写回寄存器堆的来源。0：ALU运算结果，1：存储器数据 mem_write 存储器写使能 mem_read 存储器读使能 2、ALU单元 ALU单元根据传入的aluopType进行不同的计算。同时负责计算next_Pc和访存的地址 val res = LookupTreeDefault(aluOpType, adderRes, List( ALUOpType.sll -> ((src1 (src1 >> shamt), ALUOpType.sra -> ((src1.asSInt >> shamt).asUInt), ALUOpType.slt -> ZeroExt(less, XLEN), ALUOpType.sltu -> ZeroExt(less_u, XLEN), ALUOpType.xor -> (src1 ^ src2), ALUOpType.or -> (src1 | src2), ALUOpType.and -> (src1 & src2), ALUOpType.addw -> SignExt((adderRes)(31,0), 64), ALUOpType.subw -> SignExt((adderRes)(31,0), 64), ALUOpType.sllw -> SignExt((src1 SignExt((shsrc1 >> shamt)(31,0),64), ALUOpType.sraw -> SignExt(((shsrc1.asSInt >> shamt).asUInt)(31,0) ,64), ALUOpType.beq -> !(src1 ^ src2).orR, ALUOpType.bne -> (src1 ^ src2).orR, ALUOpType.blt -> less, ALUOpType.bltu -> less_u, ALUOpType.bge -> !less, ALUOpType.bgeu -> !less_u, )) 特殊指令的处理 需要特别关注的指令： LUI： 加载长立即数到rd中。操作数1：0号寄存器。操作数2：立即数。零号寄存器加上立即数写入rd寄存器 💡 ALU加法操作：rd = reg(0)+imm AUIPC： PC加上立即数。操作数1：pc；操作数2：立即数 💡 ALU加法操作：rd = PC+imm JAL：无条件跳转 （JAL、JALR可以在译码阶段就能获得跳转地址。）操作数1：pc；操作数2：立即数(offset) 记录下一条pc值(rd = pc+4), pc+4应该作为ALU的运算结果，最终写回寄存器。同时，需要计算目标地址（nextPc)设为 pc + offset（imm) 💡 ALU加法操作：res = pc + 4; target = pc+offset JALR：链接并跳转 操作数1：rs1（寄存器读端口1的值）操作数2：立即数（offset)。 记录下一条pc值(rd = pc+4), pc+4应该作为ALU的运算结果，最终写回寄存器。同时，需要计算目标地址（nextPc)设为 reg + offset（imm) 💡 ALU加法操作：res = pc + 4; target = reg+offset B类指令 操作数1：rs1（寄存器读端口1的值）操作数2：rs2（寄存器读端口1的值） ALU比较rs1和rs2（相等、小于、大于……）。ALU得出是否跳转：taken。如果taken， 设置target_pc = pc + offset 3、MDU乘除法单元 乘除法计算。目前直接用*、/和% val mulRes = src1 * src2 val res = LookupTreeDefault(mduOpType, mulRes, List( MDUOpType.mul -> (src1 * src2)(63, 0), MDUOpType.mulh -> ((src1.asSInt * src2.asSInt).asUInt >> 32), MDUOpType.div -> (src1.asSInt / src2.asSInt).asUInt, MDUOpType.divu -> (src1 / src2)(63,0), MDUOpType.rem -> (src1.asSInt % src2.asSInt).asUInt, MDUOpType.remu -> (src1 % src2), …… )) 4、存储模块 ①使用C语言申请一个可读写的大数组，模拟内存。 uint8_t pmem[CONFIG_MSIZE]; extern \"C\" void pmem_read(long long raddr, long long *rdata) { // 总是读取地址为`raddr & ~0x7ull`的8字节返回给`rdata` } extern \"C\" void pmem_write(long long waddr, long long wdata, char wmask) { // 总是往地址为`waddr & ~0x7ull`的8字节按写掩码`wmask`写入`wdata` // `wmask`中每比特表示`wdata`中1个字节的掩码, // 如`wmask = 0x3`代表只写入最低2个字节, 内存中的其它字节保持不变 } ②用verilog写存储器部分，使用DPI-C机制，调用读写存储器函数 import \"DPI-C\" function void pmem_read( input longint raddr, output longint rdata); import \"DPI-C\" function void pmem_write( input longint waddr, input longint wdata, input byte wmask); XXXX always @(*) begin if(mem_read == 1'b1) begin pmem_read(address, read_data); end if(mem_write == 1'b1) begin pmem_write(address, write_data, w_mask); end end ③使用chisel的blackbox机制包裹PmemHarness.v class PmemHarness extends BlackBox with HasBlackBoxResource { val io = IO(new Bundle{ val clock = Input(Clock()) val reset = Input(Bool()) val mem_read = Input(UInt(1.W))//control signal val mem_write = Input(UInt(1.W))//control signal …… }) addResource(\"/vsrc/PmemHarness.v\") } pmem_read和pmem_write中模拟了64位总线的行为: 它们只支持地址按8字节对齐的读写, 其中读操作总是返回按8字节对齐读出的数据, 需要由RTL代码根据读地址选择出需要的部分: val mask = LookupTreeDefault(lsuOpType, \"b1111_1111\".U, List( LSUOpType.sb -> \"b0000_0001\".U, LSUOpType.sh -> \"b0000_0011\".U, LSUOpType.sw -> \"b0000_1111\".U, LSUOpType.sd -> \"b1111_1111\".U )) mem.io.w_mask := mask val rdataSel = mem.io.read_data val rdataPartialLoad = LookupTreeDefault(lsuOpType, \"b0\".U(64.W), List( LSUOpType.lb -> SignExt(rdataSel(7, 0) , 64), LSUOpType.lh -> SignExt(rdataSel(15, 0), 64), LSUOpType.lw -> SignExt(rdataSel(31, 0), 64), LSUOpType.ld -> SignExt(rdataSel(63, 0), 64), LSUOpType.lbu -> ZeroExt(rdataSel(7, 0) , 64), LSUOpType.lhu -> ZeroExt(rdataSel(15, 0), 64), LSUOpType.lwu -> ZeroExt(rdataSel(31, 0), 64) )) io.read_data := rdataPartialLoad "},"ysyx/riscvCpu/PipelineCpu.html":{"url":"ysyx/riscvCpu/PipelineCpu.html","title":"顺序五级流水线CPU","keywords":"","body":"顺序五级流水CPU设计 1、流水线概述 参考资料（请提前阅读） 《CPU设计实战》第四章。 《计算机组成与设计 硬件软件接口（第五版）》第四章中关于流水线的部分 \"一生一芯\"讲义：流水线处理器 组合逻辑：任何时刻，当输入变化时，立刻得到相应的输出，不需要等到时钟上升沿。如ALU运算单元，当传入不同的操作数时，运算结果即刻发生变化。 时序逻辑：只有当时钟上升沿时，模块的输出才会根据输入发生变化。如PC模块，当时钟上升沿时，更新pc寄存器的值。 在原有的单周期CPU设计中，除了PC模块外，其余部分均为组合逻辑（包括存储模块），因此可以在一个周期内完成指令的执行。为了提高时钟频率，对电路进行流水化。这里按经典的五级流水进行划分 取指（IF）：生成next_pc、取出指令 译码（ID）：生成控制信号、读取寄存器获取操作数 执行（EXE）：执行指令（算术计算、跳转地址、访存地址） 访存（MEM）：从存储器中读取、写入数据 写回（WB）：将结果（运算结果、访存结果）写入目标寄存器 流水化本身并不复杂，将原本单周期的组合逻辑按照功能划分成五个阶段，在每一个阶段的组合逻辑之间插入时序器件（称为流水线寄存器），把组合逻辑分开就完成了。前一阶段的组合逻辑输出接入时序器件的输入,后一阶段的组合逻辑输入来自这些时序器件的输出。 以两个流水级的名字来命名这些寄存器，如位于取指级、译码级之间的寄存器记为REG_IF_ID。 2、不考虑冲突和分支指令的流水线设计 LW的五级流水旅程 以指令lw a4,8(s0)为例: 第一个时钟周期（IF）：处于IF阶段，根据当前pc值，从指令存储器IM中获取指令。并将pc、指令存放到RGE_IF_ID中（寄存器的值下一个时钟上升沿才会变化，因此需要等第二个时钟周期，下一个阶段才能读取到流水线寄存器中的数据）。 第二个时钟周期（ID）：RGE_IF_ID中的内容输出到ID模块，译码单元进行译码，生成控制信号（如，rs = s0, imm = 8, rd = a4，mem_read = 1）。需要将寄存器中读取的数据，以及后续流水需要的所有控制信号输出到RGE_ID_EX流水线寄存器中。 第三个时钟周期（EXE）：运算单元从RGE_ID_EXE流水线寄存器中，得知操作数1为寄存器，操作数2为立即数，最终会计算得到访存的地址为R(s0)+imm。将运算结果（访存地址）和后续流水需要的控制信号存放到RGE_EX_MEM中。 第四个时钟周期（MEM）：存储单元从RGE_EX_MEM流水线寄存器中，获取到访存的地址以及读写信号（mem_read=1,mem_write=0），读取目标地址，获取对应的数据。将读取的数据、运算单元的结果以及写回级需要的控制信号存放到RGE_MEM_WB寄存器中。 第五个时钟周期（WB）：写回级从RGE_MEM_WB寄存器中获取到执行级的运算结果、存储器中读取的数据、选择信号、寄存器写使能信号、目标寄存器号。选择信号sel_rf_res=1，因此将存储器读取的数据写回到目标寄存器a4中。至此，lw完成了五级流水的全部旅程。 流水线寄存器中需要存放的内容包括： 有效位：1bit，用于标识该流水线寄存器中的内容是否有效 数据：如pc、指令、操作数、运算结果、访存结果等 控制信号：如寄存器读使能、ALU操作类型、存储器读写控制信号等。 一根信号线可能会被多个流水寄存器多次隔断，因此每个流水线寄存器中都要包含这跟信号线携带的信息。如寄存器写使能rfWen、目标寄存器号rd在译码级就可以得到，但是等到写回级才需要使用。因此需要将其依次写入REG_ID_EX、REG_EX_MEM、REG_MEM_WB流水线寄存器中。 流水线寄存器的实现 先明确各流水线寄存器中存放的内容，再去写具体的代码。 以REG_EX_MEM为例，需要存放的内容包括： 有效位valid、pc、inst（指令） 数据内容：执行级运算结果（exe_res)、访存级读取的数据(write_data) 控制信号：数据存储器相关控制信号（fuOpType、mem_read、mem_write)、寄存器堆控制信号（rfWen、rfDest）、写回数据选择信号（sel_rf_res) class BUS_EX_MEM extends Bundle{ val valid = Bool() val pc = UInt(64.W) val inst = UInt(32.W) val write_data = UInt(64.W) val exe_res = UInt(64.W) val fuOpType = UInt(7.W) val mem_read = UInt(1.W) val mem_write = UInt(1.W) val rfWen = UInt(1.W) val rfDest = UInt(5.W) val sel_rf_res = UInt(1.W) } ​ 如下代码所示，REG_EX_MEM寄存器的输入输出类型均为上述定义的BUS_EX_MEM。ex_mem_reg初始化为BUS_EX_MEM类型的寄存器。下一个周期才能从io.out中读出当拍的流水线寄存器中的内容。(如何这里很难理解，请查阅chisel中RegInit、RegNext的用法，或者查看生成的Verilog代码)。 class PipelineReg_EX_MEM extends Module{ val io = IO(new Bundle{ val in = Input(new BUS_EX_MEM) val out = Output(new BUS_EX_MEM) }) val ex_mem_reg = RegInit(0.U.asTypeOf(new BUS_EX_MEM)) ex_mem_reg := io.in io.out := ex_mem_reg } 顶层模块 顶层TOP模块需要实例化五大模块、模块间的寄存器，并进行控制信号的连接。 val ifu = Module(new IFU()) val reg_if_id = Module(new PipelineReg_IF_ID()) val idu = Module(new IDU()) …… ifu.io.out <> reg_if_id.io.in reg_if_id.io.out <> idu.io.in idu.io.out <> reg_id_ex.io.in …… 3、考虑指令数据相关性冲突 关于相关性冲突的原理可以参考《计算机组成与设计 硬件软件接口（第五版）》中4.7章的内容。sub指令要在第五个周期才能写回x2的值（第六个周期才能读出正确的x2)，但是and、or、add指令分别在第3、4、5周期就需要访问寄存器堆，获取x2寄存器的值。如果不对流水线进行任何干扰，则and、or、add都会读出错误的x2。解决的一个办法是流水线停顿：当译码阶段发现有数据冲突时，暂停后续流水的执行，直到数据冲突被解决。 需要考虑两个问题：①如何判断数据冲突②如何停顿流水线 数据冲突的判定条件 关于如何判断数据冲突：当译码级，发现处于执行、访存、写回级的指令的目的寄存器和当前指令的某一个源寄存器相同时，则存在数据冲突。然而并不是所有的指令都会写回寄存器，一个简单的方法是，判断流水线寄存器中rfWen信号是否有效。另一方面，RISC-V中规定，x0寄存器的值恒为零，因此对x0寄存器的操作并不会引发数据冲突。据此，可以将RAW数据冲突的判定条件归为三点。以判定执行级和译码级间是否有数据冲突为例进行说明： REG_ID_EXE中rd != x0 REG_ID_EXE中rfWen == 1 REG_ID_EXE中rd == rs1 || rd == rs2,其中rs1、rs2位于译码级 你需要引入一个新的硬件单元HazardDection，该模块的输出一个stall信号(Bool类型），用于标识是否存在数据冲突。 流水线停顿 当检测到存在数据冲突时，需要停顿流水线。 只需要简单地禁止PC寄存器和IF/ID流水线寄存器的改变就可以阻止这两条指令的执行。如果这些寄存器被保护，在IF阶段的指令就会继续使用相同的PC值取指令，同时在ID阶段的寄存器就会继续使用IF/ID流水线寄存器中相同的字段读寄存器。再回到我们的洗衣例子中，这就像是你重新开启洗衣机洗相同的衣服并且让烘干机继续空转一样。当然，就像烘干机那样，EX阶段开始的流水线后半部分必须执行没有任何效果的指令,也就是空指令。 ​ ----《计算机组成与设计 硬件软件接口（第五版）》P216 HazardDection单元stall输出接入到IFU、REG_IF_ID、IDU中。 IFU检测到stall为1时，使用相同的PC再次取值 REG_IF_ID：当stall为1时，不更新寄存器内容，因此输出与上一拍一致，IDU会使用相同的指令译码 IDU：stall为1时，将输出到REG_ID_EX的控制信号全部置为0，这样后续流水不会对存储器、寄存器写入任何值，相当于执行了空指令。 4、考虑跳转 在本文的设计中，分支跳转与否、分支跳转目标在执行级确定。流水线停顿可以解决分支指令，也就是当分支跳转、分支目标被确定后再继续IF阶段。但这样非常的耗时。一个简单的策略是：假设分支不发生，继续顺序取指，如果EXE阶段发现分支跳转了，则进行流水线冲刷。 具体来说，在本文的顺序流水线中，当执行级的分支指令被处理，并确定分支发生时，需要清除处于IF阶段、ID阶段的内容，即将REG_IF_ID、REG_ID_EX中的内容全部置为0。于此同时，需要将HazardDection的stall值置为false。 when(exeu.io.redirect.valid){ reg_if_id.io.flush := true.B reg_id_ex.io.flush := true.B hd.io.flush := true.B } 调整后的五级流水示意图如下 "}}