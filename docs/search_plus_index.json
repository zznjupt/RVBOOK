{"./":{"url":"./","title":"README","keywords":"","body":"实验室项目记录RVBOOK 和个人项目记录 仓库维护者：周喆 实验室成员：江芳、程晓宇、周喆 个人项目记录：周喆 "},"workspace/help-docs/chipyard-install.html":{"url":"workspace/help-docs/chipyard-install.html","title":"Chipyard-1.8.0安装","keywords":"","body":"Chipyard 1.8.0安装 0、 版本 名称 版本 Ubuntu 20.04 chipyard 1.5.0 conda 4.12.0 或更高版本 verilator 4.226 boom 头指针位于 commit fac2c370c9deae97ca52aca6b34857e9ac0f6e9d 细节请参考chipyard 1.8.0安装文档。 1 、安装Conda 在chipyard1.8.0中，使用Conda管理项目依赖。参阅 Conda 安装说明，了解如何使用 Miniforge 安装程序安装 Conda。具体操作： curl -L -O \"https://github.com/conda-forge/miniforge/releases/latest/download/Mambaforge-$(uname)-$(uname -m).sh\" bash Mambaforge-$(uname)-$(uname -m).sh 关闭终端，重新打开后，会生效。终端前出现 (base)。运行conda --version 查看版本。要求conda版本大于等于4.12.0。 接着，安装conda-lock（Conda lock is a lightweight library that can be used to generate fully reproducible lock files for conda environments.） conda install -n base conda-lock conda activate base 2、 初始化子模块&安装工具链 ① 拉取chipyard仓库，并切换到1.8.0版本 git clone https://github.com/ucb-bar/chipyard.git cd chipyard git checkout 1.8.0 ② 运行初始化脚本 该脚本将会创建chipyard Conda环境，包括riscv工具链 运行该脚本时，还会运行init-submodules-no-riscv-tools.sh 和 build-toolchain-extra.sh 两个脚本 建议阅读相应脚本，弄清大致完成了哪些操作 ./build-setup.sh riscv-tools 运行完成后，通过命令conda env list，将会有一个chipyard相关的环境：$CHIPYARD_DIRECTORY/.conda-env ③ 设置环境变量 通过运行以下命令，进而： 激活在 build-setup.sh 中创建的 conda 环境 设置将来 Chipyard 步骤所需的必要环境变量（PATH、RISCV 、LD_LIBRARY_PATH） source ./env.sh 注：每次运行make命令时，都需要进行这一步 3、 修补部分缺失模块 因为网络问题，会有子模块拉取失败的情况。这样会导致在编译Boom时出现很多错误，如： 在上一步，运行build-setup.sh脚本时，会在chipyard目录下，生成init-submodules-no-riscv-tools.log文件。记录了该脚本运行的情况，可以通过查看日志，看到哪些子模块拉取失败了。 同时，可以在chipyard/.gitmodules中查看，chipyard具体有哪些子模块。 接下来，面对缺失的子模块，如tools/torture，你可以通过以下命令来获取。 git submodule update --init --recursive tools/torture 请确保generators和tools目录下的所有子模块都拉取下来了。有时候，它只有文件夹，里面的内容不全，最好一个个文件夹点进去确认一下。 4、 生成Boom chipyard可以使用Verilator下载、构建和执行仿真。通过CONFIG指定编译的项目。可以在chipyard/generators/chipyard/src/main/scala/config/BoomConfigs.scala 查看可选的BOOM配置名称。 将会生成一个名为``的可执行文件。可以使用此可执行文件运行任何兼容的 RV64 代码。例如，运行其中一个 riscv 工具链中集成的测试文件。 # Enter Verilator directory cd sims/verilator make CONFIG=SmallBoomConfig ./simulator-chipyard-RocketConfig $RISCV/riscv64-unknown-elf/share/riscv-tests/isa/rv64ui-p-simple 编译的过程，会在终端上，输出大量的内容，可以将终端的内容输入到日志文件中： make CONFIG=SmallBoomConfig 2>&1 | tee > LOGNAME.log 可以通过阅读日志，了解Makefile文件具体帮你完成了什么，verilator的顶层模块是哪一个，如何得到最终的可执行文件的。 "},"workspace/riscvCpu/SingleCycleCore.html":{"url":"workspace/riscvCpu/SingleCycleCore.html","title":"Chisel-单周期非流水CPU","keywords":"","body":"单周期CPU设计 参考内容 The RISC-V Instruction Set Manual (Volume I） 《CPU设计实战》第四章P75-P92 《计算机组成与设计 硬件软件接口（第五版）》第四章4.1-4.4小节 NutShell源码 Trigger：chisel写的4级流水线顺序单发射处理器核 在次之前，你需要对RISC-V指令集有个简单的了解。本文的单周期处理器支持RISCV64IM指令。 1、译码模块 指令集 这里仿照果壳Nutshell的译码方式。通过BitPat匹配指令，同时每一条指令都绑定了具体的指令类型、操作单元以及具体的操作。 //RV64MInstr def MULW = BitPat(\"b0000001_?????_?????_000_?????_0111011\") def DIVW = BitPat(\"b0000001_?????_?????_100_?????_0111011\") def DIVUW = BitPat(\"b0000001_?????_?????_101_?????_0111011\") def REMW = BitPat(\"b0000001_?????_?????_110_?????_0111011\") def REMUW = BitPat(\"b0000001_?????_?????_111_?????_0111011\") val RV64M_Table = Array( MULW -> List(InstrR, FuType.mdu, MDUOpType.mulw), DIVW -> List(InstrR, FuType.mdu, MDUOpType.divw), DIVUW -> List(InstrR, FuType.mdu, MDUOpType.divuw), REMW -> List(InstrR, FuType.mdu, MDUOpType.remw), REMUW -> List(InstrR, FuType.mdu, MDUOpType.remuw) ) 在译码单元，通过以下命令就可以获取指令的类型和操作类型。 val decodeList = ListLookup(instr, Instructions.DecodeDefault, Instructions.DecodeTable) val instrType = decodeList(0) val fuType = decodeList(1) val fuOpType = decodeList(2) 控制信号 译码模块根据instrType、fuType、fuOpType生成以下控制信号： 控制信号 含义 instrType 指令类型（I、R、S、B、U、J） fuType 操作单元（ALU、LSU、MDU等） fuOpType 具体操作（如add、sub、jal等） alu1Type ALU操作数1类型，0：寄存器，1：PC alu2Type ALU操作数2类型，0：寄存器，1：imm rfSrc1 源寄存器rs rfSrc2 源寄存器rt rfWen 寄存器堆写使能 rfDest 目的寄存器 imm 立即数 sel_rf_res 写回寄存器堆的来源。0：ALU运算结果，1：存储器数据 mem_write 存储器写使能 mem_read 存储器读使能 2、ALU单元 ALU单元根据传入的aluopType进行不同的计算。同时负责计算next_Pc和访存的地址 val res = LookupTreeDefault(aluOpType, adderRes, List( ALUOpType.sll -> ((src1 (src1 >> shamt), ALUOpType.sra -> ((src1.asSInt >> shamt).asUInt), ALUOpType.slt -> ZeroExt(less, XLEN), ALUOpType.sltu -> ZeroExt(less_u, XLEN), ALUOpType.xor -> (src1 ^ src2), ALUOpType.or -> (src1 | src2), ALUOpType.and -> (src1 & src2), ALUOpType.addw -> SignExt((adderRes)(31,0), 64), ALUOpType.subw -> SignExt((adderRes)(31,0), 64), ALUOpType.sllw -> SignExt((src1 SignExt((shsrc1 >> shamt)(31,0),64), ALUOpType.sraw -> SignExt(((shsrc1.asSInt >> shamt).asUInt)(31,0) ,64), ALUOpType.beq -> !(src1 ^ src2).orR, ALUOpType.bne -> (src1 ^ src2).orR, ALUOpType.blt -> less, ALUOpType.bltu -> less_u, ALUOpType.bge -> !less, ALUOpType.bgeu -> !less_u, )) 特殊指令的处理 需要特别关注的指令： LUI： 加载长立即数到rd中。操作数1：0号寄存器。操作数2：立即数。零号寄存器加上立即数写入rd寄存器 💡 ALU加法操作：rd = reg(0)+imm AUIPC： PC加上立即数。操作数1：pc；操作数2：立即数 💡 ALU加法操作：rd = PC+imm JAL：无条件跳转 （JAL、JALR可以在译码阶段就能获得跳转地址。）操作数1：pc；操作数2：立即数(offset) 记录下一条pc值(rd = pc+4), pc+4应该作为ALU的运算结果，最终写回寄存器。同时，需要计算目标地址（nextPc)设为 pc + offset（imm) 💡 ALU加法操作：res = pc + 4; target = pc+offset JALR：链接并跳转 操作数1：rs1（寄存器读端口1的值）操作数2：立即数（offset)。 记录下一条pc值(rd = pc+4), pc+4应该作为ALU的运算结果，最终写回寄存器。同时，需要计算目标地址（nextPc)设为 reg + offset（imm) 💡 ALU加法操作：res = pc + 4; target = reg+offset B类指令 操作数1：rs1（寄存器读端口1的值）操作数2：rs2（寄存器读端口1的值） ALU比较rs1和rs2（相等、小于、大于……）。ALU得出是否跳转：taken。如果taken， 设置target_pc = pc + offset 3、MDU乘除法单元 乘除法计算。目前直接用*、/和% val mulRes = src1 * src2 val res = LookupTreeDefault(mduOpType, mulRes, List( MDUOpType.mul -> (src1 * src2)(63, 0), MDUOpType.mulh -> ((src1.asSInt * src2.asSInt).asUInt >> 32), MDUOpType.div -> (src1.asSInt / src2.asSInt).asUInt, MDUOpType.divu -> (src1 / src2)(63,0), MDUOpType.rem -> (src1.asSInt % src2.asSInt).asUInt, MDUOpType.remu -> (src1 % src2), …… )) 4、存储模块 ①使用C语言申请一个可读写的大数组，模拟内存。 uint8_t pmem[CONFIG_MSIZE]; extern \"C\" void pmem_read(long long raddr, long long *rdata) { // 总是读取地址为`raddr & ~0x7ull`的8字节返回给`rdata` } extern \"C\" void pmem_write(long long waddr, long long wdata, char wmask) { // 总是往地址为`waddr & ~0x7ull`的8字节按写掩码`wmask`写入`wdata` // `wmask`中每比特表示`wdata`中1个字节的掩码, // 如`wmask = 0x3`代表只写入最低2个字节, 内存中的其它字节保持不变 } ②用verilog写存储器部分，使用DPI-C机制，调用读写存储器函数 import \"DPI-C\" function void pmem_read( input longint raddr, output longint rdata); import \"DPI-C\" function void pmem_write( input longint waddr, input longint wdata, input byte wmask); XXXX always @(*) begin if(mem_read == 1'b1) begin pmem_read(address, read_data); end if(mem_write == 1'b1) begin pmem_write(address, write_data, w_mask); end end ③使用chisel的blackbox机制包裹PmemHarness.v class PmemHarness extends BlackBox with HasBlackBoxResource { val io = IO(new Bundle{ val clock = Input(Clock()) val reset = Input(Bool()) val mem_read = Input(UInt(1.W))//control signal val mem_write = Input(UInt(1.W))//control signal …… }) addResource(\"/vsrc/PmemHarness.v\") } pmem_read和pmem_write中模拟了64位总线的行为: 它们只支持地址按8字节对齐的读写, 其中读操作总是返回按8字节对齐读出的数据, 需要由RTL代码根据读地址选择出需要的部分: val mask = LookupTreeDefault(lsuOpType, \"b1111_1111\".U, List( LSUOpType.sb -> \"b0000_0001\".U, LSUOpType.sh -> \"b0000_0011\".U, LSUOpType.sw -> \"b0000_1111\".U, LSUOpType.sd -> \"b1111_1111\".U )) mem.io.w_mask := mask val rdataSel = mem.io.read_data val rdataPartialLoad = LookupTreeDefault(lsuOpType, \"b0\".U(64.W), List( LSUOpType.lb -> SignExt(rdataSel(7, 0) , 64), LSUOpType.lh -> SignExt(rdataSel(15, 0), 64), LSUOpType.lw -> SignExt(rdataSel(31, 0), 64), LSUOpType.ld -> SignExt(rdataSel(63, 0), 64), LSUOpType.lbu -> ZeroExt(rdataSel(7, 0) , 64), LSUOpType.lhu -> ZeroExt(rdataSel(15, 0), 64), LSUOpType.lwu -> ZeroExt(rdataSel(31, 0), 64) )) io.read_data := rdataPartialLoad "},"workspace/riscvCpu/PipelineCpu.html":{"url":"workspace/riscvCpu/PipelineCpu.html","title":"Chisel-顺序五级流水线CPU","keywords":"","body":"顺序五级流水CPU设计 1、流水线概述 参考资料（请提前阅读） 《CPU设计实战》第四章。 《计算机组成与设计 硬件软件接口（第五版）》第四章中关于流水线的部分 \"一生一芯\"讲义：流水线处理器 组合逻辑：任何时刻，当输入变化时，立刻得到相应的输出，不需要等到时钟上升沿。如ALU运算单元，当传入不同的操作数时，运算结果即刻发生变化。 时序逻辑：只有当时钟上升沿时，模块的输出才会根据输入发生变化。如PC模块，当时钟上升沿时，更新pc寄存器的值。 在原有的单周期CPU设计中，除了PC模块外，其余部分均为组合逻辑（包括存储模块），因此可以在一个周期内完成指令的执行。为了提高时钟频率，对电路进行流水化。这里按经典的五级流水进行划分 取指（IF）：生成next_pc、取出指令 译码（ID）：生成控制信号、读取寄存器获取操作数 执行（EXE）：执行指令（算术计算、跳转地址、访存地址） 访存（MEM）：从存储器中读取、写入数据 写回（WB）：将结果（运算结果、访存结果）写入目标寄存器 流水化本身并不复杂，将原本单周期的组合逻辑按照功能划分成五个阶段，在每一个阶段的组合逻辑之间插入时序器件（称为流水线寄存器），把组合逻辑分开就完成了。前一阶段的组合逻辑输出接入时序器件的输入,后一阶段的组合逻辑输入来自这些时序器件的输出。 以两个流水级的名字来命名这些寄存器，如位于取指级、译码级之间的寄存器记为REG_IF_ID。 2、不考虑冲突和分支指令的流水线设计 LW的五级流水旅程 以指令lw a4,8(s0)为例: 第一个时钟周期（IF）：处于IF阶段，根据当前pc值，从指令存储器IM中获取指令。并将pc、指令存放到RGE_IF_ID中（寄存器的值下一个时钟上升沿才会变化，因此需要等第二个时钟周期，下一个阶段才能读取到流水线寄存器中的数据）。 第二个时钟周期（ID）：RGE_IF_ID中的内容输出到ID模块，译码单元进行译码，生成控制信号（如，rs = s0, imm = 8, rd = a4，mem_read = 1）。需要将寄存器中读取的数据，以及后续流水需要的所有控制信号输出到RGE_ID_EX流水线寄存器中。 第三个时钟周期（EXE）：运算单元从RGE_ID_EXE流水线寄存器中，得知操作数1为寄存器，操作数2为立即数，最终会计算得到访存的地址为R(s0)+imm。将运算结果（访存地址）和后续流水需要的控制信号存放到RGE_EX_MEM中。 第四个时钟周期（MEM）：存储单元从RGE_EX_MEM流水线寄存器中，获取到访存的地址以及读写信号（mem_read=1,mem_write=0），读取目标地址，获取对应的数据。将读取的数据、运算单元的结果以及写回级需要的控制信号存放到RGE_MEM_WB寄存器中。 第五个时钟周期（WB）：写回级从RGE_MEM_WB寄存器中获取到执行级的运算结果、存储器中读取的数据、选择信号、寄存器写使能信号、目标寄存器号。选择信号sel_rf_res=1，因此将存储器读取的数据写回到目标寄存器a4中。至此，lw完成了五级流水的全部旅程。 流水线寄存器中需要存放的内容包括： 有效位：1bit，用于标识该流水线寄存器中的内容是否有效 数据：如pc、指令、操作数、运算结果、访存结果等 控制信号：如寄存器读使能、ALU操作类型、存储器读写控制信号等。 一根信号线可能会被多个流水寄存器多次隔断，因此每个流水线寄存器中都要包含这跟信号线携带的信息。如寄存器写使能rfWen、目标寄存器号rd在译码级就可以得到，但是等到写回级才需要使用。因此需要将其依次写入REG_ID_EX、REG_EX_MEM、REG_MEM_WB流水线寄存器中。 流水线寄存器的实现 先明确各流水线寄存器中存放的内容，再去写具体的代码。 以REG_EX_MEM为例，需要存放的内容包括： 有效位valid、pc、inst（指令） 数据内容：执行级运算结果（exe_res)、访存级读取的数据(write_data) 控制信号：数据存储器相关控制信号（fuOpType、mem_read、mem_write)、寄存器堆控制信号（rfWen、rfDest）、写回数据选择信号（sel_rf_res) class BUS_EX_MEM extends Bundle{ val valid = Bool() val pc = UInt(64.W) val inst = UInt(32.W) val write_data = UInt(64.W) val exe_res = UInt(64.W) val fuOpType = UInt(7.W) val mem_read = UInt(1.W) val mem_write = UInt(1.W) val rfWen = UInt(1.W) val rfDest = UInt(5.W) val sel_rf_res = UInt(1.W) } ​ 如下代码所示，REG_EX_MEM寄存器的输入输出类型均为上述定义的BUS_EX_MEM。ex_mem_reg初始化为BUS_EX_MEM类型的寄存器。下一个周期才能从io.out中读出当拍的流水线寄存器中的内容。(如果这里很难理解，请查阅chisel中RegInit、RegNext的用法，或者查看生成的Verilog代码)。 class PipelineReg_EX_MEM extends Module{ val io = IO(new Bundle{ val in = Input(new BUS_EX_MEM) val out = Output(new BUS_EX_MEM) }) val ex_mem_reg = RegInit(0.U.asTypeOf(new BUS_EX_MEM)) ex_mem_reg := io.in io.out := ex_mem_reg } 顶层模块 顶层TOP模块需要实例化五大模块、模块间的寄存器，并进行控制信号的连接。 val ifu = Module(new IFU()) val reg_if_id = Module(new PipelineReg_IF_ID()) val idu = Module(new IDU()) …… ifu.io.out <> reg_if_id.io.in reg_if_id.io.out <> idu.io.in idu.io.out <> reg_id_ex.io.in …… 3、考虑指令数据相关性冲突 关于相关性冲突的原理可以参考《计算机组成与设计 硬件软件接口（第五版）》中4.7章的内容。sub指令要在第五个周期才能写回x2的值（第六个周期才能读出正确的x2)，但是and、or、add指令分别在第3、4、5周期就需要访问寄存器堆，获取x2寄存器的值。如果不对流水线进行任何干扰，则and、or、add都会读出错误的x2。解决的一个办法是流水线停顿：当译码阶段发现有数据冲突时，暂停后续流水的执行，直到数据冲突被解决。 需要考虑两个问题：①如何判断数据冲突②如何停顿流水线 数据冲突的判定条件 关于如何判断数据冲突：当译码级，发现处于执行、访存、写回级的指令的目的寄存器和当前指令的某一个源寄存器相同时，则存在数据冲突。然而并不是所有的指令都会写回寄存器，一个简单的方法是，判断流水线寄存器中rfWen信号是否有效。另一方面，RISC-V中规定，x0寄存器的值恒为零，因此对x0寄存器的操作并不会引发数据冲突。据此，可以将RAW数据冲突的判定条件归为三点。以判定执行级和译码级间是否有数据冲突为例进行说明： REG_ID_EXE中rd != x0 REG_ID_EXE中rfWen == 1 REG_ID_EXE中rd == rs1 || rd == rs2,其中rs1、rs2位于译码级 你需要引入一个新的硬件单元HazardDection，该模块的输出一个stall信号(Bool类型），用于标识是否存在数据冲突。 流水线停顿 当检测到存在数据冲突时，需要停顿流水线。 只需要简单地禁止PC寄存器和IF/ID流水线寄存器的改变就可以阻止这两条指令的执行。如果这些寄存器被保护，在IF阶段的指令就会继续使用相同的PC值取指令，同时在ID阶段的寄存器就会继续使用IF/ID流水线寄存器中相同的字段读寄存器。再回到我们的洗衣例子中，这就像是你重新开启洗衣机洗相同的衣服并且让烘干机继续空转一样。当然，就像烘干机那样，EX阶段开始的流水线后半部分必须执行没有任何效果的指令,也就是空指令。 ​ ----《计算机组成与设计 硬件软件接口（第五版）》P216 HazardDection单元stall输出接入到IFU、REG_IF_ID、IDU中。 IFU检测到stall为1时，使用相同的PC再次取值 REG_IF_ID：当stall为1时，不更新寄存器内容，因此输出与上一拍一致，IDU会使用相同的指令译码 IDU：stall为1时，将输出到REG_ID_EX的控制信号全部置为0，这样后续流水不会对存储器、寄存器写入任何值，相当于执行了空指令。 4、考虑跳转 在本文的设计中，分支跳转与否、分支跳转目标在执行级确定。流水线停顿可以解决分支指令，也就是当分支跳转、分支目标被确定后再继续IF阶段。但这样非常的耗时。一个简单的策略是：假设分支不发生，继续顺序取指，如果EXE阶段发现分支跳转了，则进行流水线冲刷。 具体来说，在本文的顺序流水线中，当执行级的分支指令被处理，并确定分支发生时，需要清除处于IF阶段、ID阶段的内容，即将REG_IF_ID、REG_ID_EX中的内容全部置为0。于此同时，需要将HazardDection的stall值置为false。 when(exeu.io.redirect.valid){ reg_if_id.io.flush := true.B reg_id_ex.io.flush := true.B hd.io.flush := true.B } 调整后的五级流水示意图如下 "},"workspace/help-docs/fangbook.html":{"url":"workspace/help-docs/fangbook.html","title":"FangBook","keywords":"","body":"FangBook 江芳的博客 Boom V3 Boom阅读、调试记录。 FangCore 一生一芯第四期项目中实现的处理器核 支持RISCV64 IM指令 经典五级流水 Booth移位乘法器、移位除法器 实现AXI4总线规范 4KB ICache、4KB Dcache 实现M模式，支持环境调用异常、时钟中断 可运行RT-thread "}}