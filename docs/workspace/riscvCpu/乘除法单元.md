# 乘除法功能单元

## 参考资料（提前阅读）

> 《CPU设计实战》第五章P140-P151
>
> 《计算机组成与设计 硬件软件接口（第五版）》第3章 P124-132
>
> 《计算机体系基础结构》[在线版](https://foxsen.github.io/archbase/%E8%BF%90%E7%AE%97%E5%99%A8%E8%AE%BE%E8%AE%A1.html#%E5%AE%9A%E7%82%B9%E8%A1%A5%E7%A0%81%E4%B9%98%E6%B3%95%E5%99%A8)

## 1、RISCV中的乘除法指令（RV64M）

计算器存储数据的时候，都是以补码的形式进行的。因此输入到乘除法器中的数据都是补码形式，有无符号影响内部的运算，最终的结果也会以补码形式返回。

### 乘法指令

积的长度是乘数和被乘数长度的和。将两个64位数相乘得到的是 128位的乘积。为了正确地得到一个有符号或无符号的 64位积。要得到整数 64位乘积（ 128位中的低 64位）就用 **mul**指令。要得到高 32位，如果操作数都是有符号数，就用 **mulh**指令；如果操作数都是无符号数，就用 **mulhu**指令；如果一个有符号一个无符号，可以用 **mulhsu**指令。在一条指令中完成把 128位积写入两个 64位寄存器的操作会使硬件设计变得复杂，所以 RV64M需要两条乘法指令才能得到一个完整的128位积。

尽管 RV64I有 64位地址且默认数据大小为 64位， 32位字仍然是程序中的有效数据类型。**mulw**是RV64M中添加的对32位乘法的支持。

| 指令   | 描述                  | 有无符号                             | 行为                                       |
| ------ | --------------------- | ------------------------------------ | ------------------------------------------ |
| mul    | 乘                    | x[rs1]、 x[rs2]均为有符号数          | 乘积写入 x[rd]                             |
| mulh   | 高位乘。              | x[rs1]、 x[rs2]均为有符号数          | 乘积的**高位**写入 x[rd]                   |
| mulhsu | 高位有符号-无符号乘。 | x[rs1]视为有符号，x[rs2]视为无符号。 | 将乘积的**高位**写入 x[rd]                 |
| mulhu  | 高位无符号乘          | x[rs1]、 x[rs2]均为无符号数          | 将乘积的**高位**写入 x[rd]                 |
| mulw   | 乘字                  | x[rs1]、 x[rs2]均为有符号数          | 乘积截为 32 位，进行有符号扩展后写入 x[rd] |

### 除法指令

RV64M 具有有符号和无符号整数的除法指令：divide(div)和divide unsigned(divu)，它们将商放入目标寄存器。在少数情况下，程序员需要余数而不是商，因此RV64M 提供remainder(rem)和remainder unsigned(remu)，它们在目标寄存器写入余数，而不是商。同时为了支持32位的除法，还添加了divw、divwu、remw、remwu。

| 指令  | 描述                                                      | 有无符合       | 行为                                   |
| ----- | --------------------------------------------------------- | -------------- | -------------------------------------- |
| div   | 用寄存器x[rs1]的值除以寄存器 x[rs2]的值                   | 有符号➗有符号  | 把商写入 x[rd]                         |
| divu  | 用寄存器x[rs1]的值除以 寄存器 x[rs2]的值                  | 无符号➗无符号  | 把商写入 x[rd]                         |
| rem   | 求余数                                                    | 有符号％有符号 | 把余数写入 x[rd]                       |
| remu  | 无符号求余数                                              | 无符号％无符号 | 把余数写入 x[rd]                       |
| divw  | 无符号字除法。x[rs1]的低 32位除以 寄存器 x[rs2]的低 32 位 | 有符号➗有符号  | 经**符号位扩展**的 32 位商写入 x[rd]   |
| divwu | 字除法。寄存器x[rs1]的低 32位除以 寄存器 x[rs2]的低 32 位 | 无符号➗无符号  | 经**符号位扩展**的 32 位商写入 x[rd]   |
| remw  | 字求余数                                                  | 有符号％有符号 | 经**符号位扩展**的 32 位余数写入 x[rd] |
| remwu | 无符号字求余数                                            | 无符号％无符号 | 经**符号位扩展**的 32 位余数写入 x[rd] |



## 2、电路级乘法器

### 2.1 简单原码移位乘法器

对于定点乘法器而言，最简单的实现方式就是通过硬件来模拟软件的迭代操作，这种乘法实现方式被称为移位加。

<img src="C:/Users/DELL/AppData/Roaming/Typora/typora-user-images/image-20220803195228283.png" alt="image-20220803195228283" style="zoom:67%;" />

### 2.2 两位booth编码

对于64位加法而言，需要将64个部分积相加才能得到结果，带来的延迟和硬件的开销很大。通过引入两位Booth编码可以显著降低减少加法的次数。具体请参考《CPU设计实战》P140。两个数补码的乘积并不等积的补码，即$\left [ x ×  y \right ]补 != \left [ x \right ]补 × \left [ y \right ]补$。下面以八位乘法为例。$\left [ y \right ]补 = y_{7}y_{6}\cdots y_{0}$。正确的是如下公式的首行，对后半部分做变化。

$\begin{aligned}& \left [ x ×  y \right ]补 = \left [ x \right ]补 × （-y_{7}\times 2^{7}+y_{6}\times 2^{6}+\ldots +y_{1}\times 2^{1}+y_{0}\times 2^{0}）\\ &=  \left [ x \right ]补 ×((-2y_{7}\times 2^{6}+y_{6})\times 2^{6}+(y_{5}\times 2^{6}-2y_{5})\times 2^{4}+\ldots \\ &\quad +(y_{1}\times 2^{2}-2y_{1})\times 2^{0})+y_{0}\times 2^{0}+y_{-1}\times 2^{0})\\ &= \left [ x \right ]补 × ((y_{5}+y_{6}-2y_{7})\times 2^{6}+(y_{3}+y_{4}-2y_{5})\times 2^{4}+\ldots +(y_{-1}+y_{0}-2y_{1})\times 2^{0})\end{aligned}$

Booth编码每次扫描乘数的三位来确定部分积。booth编码规则如下

<img src="C:/Users/DELL/AppData/Roaming/Typora/typora-user-images/image-20220803203934986.png" alt="image-20220803203934986" style="zoom: 67%;" />

这样，可以将乘积项减少一半。8位的乘法，通过booth编码产生4个部分积。因此可以得到，64位的乘法，通过booth编码产生32个部分积，只需要使用31次加法。加法次数从原来的63次加法，减少到31次，极大提高了效率。

### 2.3 Chisel实现基于Booth编码的补码乘法器

可以同时算出所有的部分积，然后进行加法运算得到最终的结果。但是这里采用移位的方法，每一个时钟周期得到一个部分积，所以一个周期内无法得到乘法器。64位的乘法需要32个周期才能得到结果，在乘法器进行计算的过程中需要停顿取指、译码级。乘法器模块添加接口ready、out_valid信号，用于通知执行级，乘法器是否正在运算、输出的结果是否有效。

#### ①模块接口信号

| 信号名       | 类型/位宽 | 说明                                                         |
| ------------ | --------- | ------------------------------------------------------------ |
| **输入**     |           |                                                              |
| mul_valid    | Bool      | 为高时，表示当前EXEU级的指令为乘法指令，需要进行乘法运算。该信号只需要维持一个周期。 |
| flush        | Bool      | 为高时。取消乘法，即将乘法器状态置为初始态                   |
| mul_signed   | 2位       | 2为编码。11，有符号×有符号；10，有符号×无符号；00，无符号×无符号 |
| multiplicand | 64位      | 被乘数（操作数1，上述X）                                     |
| multiplier   | 64位      | 乘数（操作数2，上述Y）                                       |
| **输出**     |           |                                                              |
| mul_ready    | Bool      | 乘法器是否可用，（如果正在运算，则不可用）                   |
| out_valid    | Bool      | 输出的结果是否有效                                           |
| result_hi    | 64位      | 高64位结果                                                   |
| result_lo    | 64位      | 低64位结果                                                   |

#### ②所需的寄存器

由于采用移位的方式无法一个周期内获得乘法结果。乘法器模块内需要声明寄存器用于保存中间结果，提供给下一个周期使用。同时引入两个状态。

```scala
    val is_mul_ready        = RegInit(true.B)//初始处于空闲状态
    val is_out_valid        = RegInit(false.B)
    val multiplicand_reg    = RegInit(0.U(130.W))//65*2被乘数寄存器
    val multiplier_reg      = RegInit(0.U(67.W))// 65位乘法，为了2位booth，最前最后补一位
    val result_reg          = RegInit(0.U(130.W))//结果寄存器
    val count               = RegInit(0.U(8.W))//计数器

    val state_idle :: state_calculate :: Nil = Enum(2)
    val mul_state           = RegInit(state_idle)//初始状态为空闲
```

当valid信号为高，且乘法器空闲（ready为高），则握手成功。乘法器从空闲态转为计算状态，同时设置寄存器的值

```scala
is(state_idle){//乘法器空闲，切换到运算状态
    when(mul_valid){//输入有效数据
        mul_state := state_calculate
		……
    }
  ……
}
```

#### ③支持有符号&无符号数乘法

为了同时支持64位有符号数和无符号数。

- 64位拓展至65位，具体操作：

- 无符号数，最高位前面再补上一个0，可以把它看作符号位为0的有符号数

- 有符号数，最高位前面补上符号位，数值不会改变

 通过这种最高位前再补上一位的方法，可以把无符号数和有符号数的处理统一起来。相应的64位数的乘法就拓展成了65位乘法。

  #### ④移位计算

- 根据booth编码确定部分积的值option_tmp。
- 根据是否为有符号数，对option_tmp进行符号拓展，或者无符号拓展，使乘积项对齐。
- 将部分积累加到最终的结果寄存器上
- 被乘数寄存器左移（对应2.2节中，对应X乘以2的n次方）、乘数寄存器右移两位（每次取最低3位确定部分积），为下一个周期准备

```scala
val option_tmp = MuxLookup(multiplier_reg(2, 0), 0.U(128.W), Array(
    "b000".U -> 0.U(128.W),
    "b001".U -> multiplicand_reg,
    "b010".U -> multiplicand_reg,
    "b011".U -> (multiplicand_reg << 1.U),
    "b100".U -> (-(multiplicand_reg << 1.U)),
    "b101".U -> (-multiplicand_reg),
    "b110".U -> (-multiplicand_reg),
    "b111".U -> 0.U(128.W)
))
val option = Mux(mul_signed(1), SignExt(option_tmp,130), ZeroExt(option_tmp,130))//被乘数是否为有符号
result_reg := result_reg + option
multiplicand_reg := (multiplicand_reg << 2)//被乘数左移两位
multiplier_reg := (multiplier_reg >> 2)//乘数右移两位   
```



## 3、电路级除法器

64位除法的商最多为64位。可以依次从商的第63位到0位尝试0或者1，这与笔算方法类似。同样的，使用这种方法无法在一个周期内完成除法运行。

### 3.1除法器接口

|            | 类型/位宽 | 说明                             |
| ---------- | --------- | -------------------------------- |
| **输入**   |           |                                  |
| dividend   | 64        | 被除数                           |
| divisor    | 64        | 除数                             |
| div_valid  | Bool      | 开始信号.为高表示输入的数据有效  |
| div_signed | Bool      | 为高，表示有符号除法             |
| flush      | Bool      | 高表示要取消除法                 |
| **输出**   |           |                                  |
| div_ready  | Bool      | 为高表示除法器空闲，可以输入数据 |
| out_valid  | Bool      | 为高表示除法器输出了有效结果     |
| quotient   | 64        | 商                               |
| remainder  | 64        | 余数                             |

### 3.2 所需寄存器

```scala
    val reg_div_ready   = RegInit(true.B)//初始化
    val reg_out_valid   = RegInit(false.B)

    val dividend_r      = RegInit(0.U(64.W))//被除数寄存器
    val divisor_r       = RegInit(0.U(64.W))//除数寄存器
    val div_res_r       = RegInit(0.U(64.W))//商-结果寄存器
    val rem_res_r       = RegInit(0.U(64.W))//余数-结果寄存器

    val minuend         = RegInit(0.U(64.W))//被减数
    val invert_div_res  = RegInit(false.B)//是否反转
    val invert_rem_res  = RegInit(false.B)//是否反转
```

### 3.3 绝对值迭代除法器状态机

四种状态和计数器的声明

```scala
    val state_idle :: state_start :: state_calculate :: state_end :: Nil = Enum(4)
    val div_state   = RegInit(state_idle)
    val count       = RegInit(0.U(8.W))
```

==①空闲状态（idle）==

当div_valid时，状态切换为start，同时初始化（复位）寄存器的值
```scala
is (state_idle) {
    when(io.div_valid){
        div_state := state_start
        reg_div_ready := false.B
        reg_out_valid := false.B  
        dividend_r := io.dividend
        divisor_r  := io.divisor
        ……设置其他寄存器的值
    }
}
```

==②开始状态（start）==

不同于乘法运算器的状态机，除了空闲和运算状态外，新增了开始和结束状态。开始状态用于在运算前进行准备工作，包括如下三点

1）判断是否除数为0，如果是直接切换到end状态

2）处理有符号负数，设置正确的被除数dividend_r、除数divisor_r、被减数minuend寄存器的值

被除数、除数寄存器中存放的是被除数和除数的绝对值。绝对值的确定：无符号数，绝对值就是本身；有符号正数，绝对值是本身；有符号负数，对补码取反加一（代码中直接使用负号就能求绝对值）。

其中被减数寄存器中值，是用来放置每i轮迭代过程中，目前被除数的高i位。用于和除数比较大小。（有点不太清除）。可以参考《CPU设计实战》P148，相当于第一轮，minuend=A[63:31]。第二轮，minuend=A[62:30]。。。

![image-20220803225403161](C:/Users/DELL/AppData/Roaming/Typora/typora-user-images/image-20220803225403161.png)

3）判断最终结果是否需要调整

- 余数的符号和被除数的符号保持一致

- 当被除数和除数符号相同时，商为正。否则，商为负

  在整个运算过程中，被除数、除数寄存器中存放的都是绝对值，因此如果商和余数的符号为负数时，需要对其进行调整。

```scala
val dividend_invert     = (-dividend_r)
val divisor_invert      = (-divisor_r) 
div_state       := state_calculate               
//
minuend := dividend_r(63)

invert_rem_res := (io.div_signed && dividend_r(63) === "b1".U)
//商的结果是否需要调整。除数和被除数符号不同时，商的结果为负数
invert_div_res := (io.div_signed && (dividend_r(63)^divisor_r(63) === "b1".U))
```

==③运算状态（calculate）==

运算状态，不断更新结果寄存器和被减数寄存器的值。

```scala
val minuend_sub_res = minuend - divisor_r
val div_result_tmp = Mux(minuend_ge_divisor, Cat(div_res_r(62,0), 1.U), Cat(div_res_r(62,0), 0.U))
val minuend_tmp = Mux(minuend_ge_divisor, minuend_sub_res(62,0), minuend(62,0))
……
is(state_calculate){
    dividend_r  := Cat(dividend_r(62,0), "b0".U)//左移一位
    div_res_r   := div_result_tmp//更新运算结果
    count       := count + 1.U(8.W)
    when(count === 63.U(8.W)){//需要64次计算
        div_state   := state_end
        rem_res_r   := Mux(minuend_ge_divisor, minuend_sub_res, minuend) //余数结果
    }.otherwise{
        minuend     := Cat(minuend_tmp(62,0), dividend_r(62))//更新被减数
    }
}
```

==④结束状态（end)==

调整最终的商和余数。修改除法器的状态已经ready和out_valid信号。

```scala
div_state       := state_idle
reg_div_ready   := false.B 
reg_out_valid   := true.B

div_res_r       := Mux(invert_div_res, -div_res_r, div_res_r)
rem_res_r       := Mux(invert_rem_res, -rem_res_r, rem_res_r)
```

## 4、接入流水线

<img src="C:/Users/DELL/AppData/Roaming/Typora/typora-user-images/image-20220803231030474.png" alt="image-20220803231030474" style="zoom:50%;" />

将乘法器和除法器封装成乘除法运算模块MDU，该模块内，：

1）根据当前指令和乘除法器状态，设置相应的valid信号，输入给乘除法器

```scala
val boothM                       = Module(new BoothMultiplier())
val (mul_ready, mul_out_valid)   = (boothM.io.mul_ready, boothM.io.out_valid)
val mul_valid      	= is_mul && !mul_doing && !mul_out_valid    /*乘法器接受数据之后到下一个除法到来之前，mul_valid都应该是零*/
when(mul_valid && mul_ready){//握手成功
    mul_doing := true.B
}.elsewhen(mul_out_valid){//乘法器运算结束
    mul_doing := false.B
}  
```

2）判断乘除法器是否忙碌，设置mul_busy、div_busy。当一方为高时，表示执行级正忙，需要阻塞流水线

```
val mul_busy 		= is_mul && !mul_out_valid
val div_busy 		= is_div && !div_out_valid
io.mdu_res      := Mux(is_mul, mul_res, div_res)
io.mdu_busy     := Mux(flush, false.B, (mul_busy | div_busy)) 
```

3）根据具体指令，处理输入到乘除法器的信号。如是否有符号

当指令为divw、divwu、remw、remwu时，还需要修改输入给除法单元的值（使得64位除法器支持34位操作：操作数截取32位，符号拓展\零拓展为64位后，使用支持64位的除法器进行运算。最终将结果的低32位符号拓展为64位，写回寄存器中）

```scala
div.io.dividend     := Mux(isdivW, Mux(is_signed, SignExt(src1(31,0), 64), ZeroExt(src1(31,0), 64)), src1)
div.io.divisor      := Mux(isdivW, Mux(is_signed, SignExt(src2(31,0), 64), ZeroExt(src2(31,0), 64)), src2)
```

4）获取乘除法器的运算结果，并根据具体指令确定最终MDU单元的值

- 乘法指令需要判断写回寄存器的值是高64位还是低64位。还要对mulw指令进行特殊处理
- 除法指令需要判断写回寄存器的值是商还是余数，需要对字除法指令进行处理

```scala
val mul_res = Mux(mduOpType === "b1000".U, SignExt(lo_res(31,0),64),//mulw
                    Mux(MDUOpType.sel_hi(mduOpType), hi_res, lo_res))
                    
   val div_res = LookupTreeDefault(mduOpType, "b0".U(64.W), List(
        MDUOpType.div        -> div.io.quotient,
        MDUOpType.divu       -> div.io.quotient,
        MDUOpType.rem        -> div.io.remainder,
        MDUOpType.remu       -> div.io.remainder,

        MDUOpType.divw       -> SignExt(div.io.quotient(31,0), 64),
        MDUOpType.divuw      -> SignExt(div.io.quotient(31,0), 64),
        MDUOpType.remw       -> SignExt(div.io.remainder(31,0), 64),
        MDUOpType.remuw      -> SignExt(div.io.remainder(31,0), 64)
    ))
    io.mdu_res      := Mux(is_mul, mul_res, div_res)

```

