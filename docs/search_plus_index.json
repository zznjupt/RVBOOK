{"./":{"url":"./","title":"README","keywords":"","body":"Links 个人主页 书籍 计算机体系结构基础-胡伟武等 Computer Architecture A Quantitative Approach 6th Edition A Primer on Memory Consistency and Cache Coherence 2-Edition 课程 CS 127/227 - Fall 2021 CS 217 - Winter 2023 useful 文档 跟我一起写Makefile GNU make UGVivado Design Suite Tcl Command Reference Guide (UG835) Others CCF Rec. Conference Deadlines Copyright © Priself.zz@gmail.com 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-04 14:50:06 "},"blog/cva6/bht.html":{"url":"blog/cva6/bht.html","title":"BHT","keywords":"","body":" cva6中的模式历史表解析 // Copyright 2018 - 2019 ETH Zurich and University of Bologna. // Copyright 2023 - Thales for additionnal conribution. // Copyright and related rights are licensed under the Solderpad Hardware // License, Version 2.0 (the \"License\"); you may not use this file except in // compliance with the License. You may obtain a copy of the License at // http://solderpad.org/licenses/SHL-2.0. Unless required by applicable law // or agreed to in writing, software, hardware and materials distributed under // this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR // CONDITIONS OF ANY KIND, either express or implied. See the License for the // specific language governing permissions and limitations under the License. // // Author: Florian Zaruba, ETH Zurich // Date: 08.02.2018 // Migrated: Luis Vitorio Cargnini, IEEE // Date: 09.06.2018 // FPGA optimization: Sebastien Jacq, Thales // Date: 2023-01-30 // branch history table - 2 bit saturation counter module bht #( parameter int unsigned NR_ENTRIES = 1024 )( input logic clk_i, input logic rst_ni, input logic flush_i, input logic debug_mode_i, input logic [riscv::VLEN-1:0] vpc_i, input ariane_pkg::bht_update_t bht_update_i, // we potentially need INSTR_PER_FETCH predictions/cycle output ariane_pkg::bht_prediction_t [ariane_pkg::INSTR_PER_FETCH-1:0] bht_prediction_o ); // the last bit is always zero, we don't need it for indexing localparam OFFSET = ariane_pkg::RVC == 1'b1 ? 1 : 2; // re-shape the branch history table localparam NR_ROWS = NR_ENTRIES / ariane_pkg::INSTR_PER_FETCH; // number of bits needed to index the row localparam ROW_ADDR_BITS = $clog2(ariane_pkg::INSTR_PER_FETCH); localparam ROW_INDEX_BITS = ariane_pkg::RVC == 1'b1 ? $clog2(ariane_pkg::INSTR_PER_FETCH) : 1; // number of bits we should use for prediction localparam PREDICTION_BITS = $clog2(NR_ROWS) + OFFSET + ROW_ADDR_BITS; // we are not interested in all bits of the address unread i_unread (.d_i(|vpc_i)); struct packed { logic valid; logic [1:0] saturation_counter; } bht_d[NR_ROWS-1:0][ariane_pkg::INSTR_PER_FETCH-1:0], bht_q[NR_ROWS-1:0][ariane_pkg::INSTR_PER_FETCH-1:0]; logic [$clog2(NR_ROWS)-1:0] index, update_pc; logic [ROW_INDEX_BITS-1:0] update_row_index; assign index = vpc_i[PREDICTION_BITS - 1:ROW_ADDR_BITS + OFFSET]; assign update_pc = bht_update_i.pc[PREDICTION_BITS - 1:ROW_ADDR_BITS + OFFSET]; if (ariane_pkg::RVC) begin : gen_update_row_index assign update_row_index = bht_update_i.pc[ROW_ADDR_BITS + OFFSET - 1:OFFSET]; end else begin assign update_row_index = '0; end if (!ariane_pkg::FPGA_EN) begin : gen_asic_bht // ASIC TARGET logic [1:0] saturation_counter; // prediction assignment for (genvar i = 0; i Copyright © Priself.zz@gmail.com 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 15:58:02 "},"blog/AI/AI芯片指标.html":{"url":"blog/AI/AI芯片指标.html","title":"AI 芯片指标","keywords":"","body":"AI 芯片指标与比特位 算力单位 OPS OPS(Operations Per Second) 1 TOPS 代表处理器每秒进行一万亿次 $(10^{12})$ 计算 OPS/W 每瓦特运算性能 TOPS/W 评价处理器在 1W 功耗下运算能力的性能指标 MACs Multiply-Accumulate Operations，乘加累积操作 1MACs 包含一个乘法操作和一个加法操作 ～ 2FLOPs，通常 MACs 与 FLOPs 存在一个2倍的关系 FLOPs Floating Point Operations，浮点运算次数，用来衡量模型计算复杂度，常用作神经网络模型速度的间接衡量标准。对于卷积层而言，FLOPs的计算公式如下： FLOPs=2∗H∗W∗Cin∗K∗K∗Cout \\text{FLOPs} = 2 * H * W * C_{\\text{in}} * K * K * C_{\\text{out}} FLOPs=2∗H∗W∗C​in​​∗K∗K∗C​out​​ MAC Memory Access Cost，内存占用量，用来评价模型在运行时的内存占用情况。 1×11\\times 11×1卷积 FLOPs 为 2∗H∗W∗Cin∗Cout2 * H * W * C_{\\text{in}} * C_{\\text{out}}2∗H∗W∗C​in​​∗C​out​​, 其对应MAC为： 2∗H∗W∗(Cin+Cout)+(Cin∗Cout) 2 * H * W * (C_{\\text{in}} + C_{\\text{out}}) + (C_{\\text{in}} * C_{\\text{out}}) 2∗H∗W∗(C​in​​+C​out​​)+(C​in​​∗C​out​​) AI 芯片关键指标（Key Metrics） 精度 Accuracy 计算精度 (FP32/FP16 etc.) 模型结果精度 (ImageNet 78%) 吞吐量 Throughput 高维张量处理 (high dimension tensor) 实时性能 (30 fps or 20 tokens) Copyright © Priself.zz@gmail.com 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-05 11:21:38 "},"blog/hardfix/":{"url":"blog/hardfix/","title":"硬件定点数","keywords":"","body":" 漫谈单精度浮点数、定点数与硬件实现 单精度浮点数格式 单精度浮点数格式是一种数据类型，在计算机存储器中占用4个字节（32 bits），利用“浮点”（浮动小数点）的方法，可以表示一个范围很大的数值。 IEEE 754-1985 single IEEE 754-2008 binary32 第1位表示正负，中间8位表示指数，后23位储存有效数位（有效数位是24位） 第一位的正负号0代表正，1代表负 中间八位共可表示2^8=256个数，指数可以是二补码；或0到255，0到126代表-127到-1，127代表零，128-255代表1-128 有效数位最左手边的1并不会储存，因为它一定存在（二进制的第一个有效数字必定是1）换言之，有效数位是24位，实际储存23位 定点数格式 定点数由若干位整数和若干位小数组成。其值 = 该二进制码对应的整数补码 除以 2^小数位数 例如，若整数位数为8，小数位数为8，举例如下表： 二进制码 整数补码 定点数值 (8位整数，8位小数) 备注 0000_0000_0000_0000 0 0.0 零值 0000_0001_0000_0000 256 1.0 / 1111_1111_0000_0000 -256 -1.0 / 0000_0000_0000_0001 1 0.00390625 正最小值 1111_1111_1111_1111 -1 -0.00390625 负最大值 0111_1111_1111_1111 32767 127.99609375 正最大值 1000_0000_0000_0000 -32768 -128.0 负最小值 0001_0101_1100_0011 5571 21.76171875 / 1001_0101_1010_0110 -27226 -106.3515625 / 浮点数转定点数 组合逻辑 module Float2Fix #( parameter WID_INT = 8, // 输入浮点数的整数位宽，默认=8 parameter WID_DEC = 8, // 输入浮点数的小数位宽，默认=8 parameter ROUND = 1 // 结果小数截断时，是否四舍五入，默认开启四舍五入 )( input wire [31:0] in, // 输入浮点数(IEEE 754 单精度) output reg [WID_INT+WID_DEC-1:0] out, // 输出定点数 output reg overflow // 结果是否溢出，若溢出则为 1'b1 // 若为上溢出，则out被置为最大正值 // 若为下溢出，则out被置为最小负值 ); initial {out, overflow} = '0; // 初始化置0 always @(*) begin logic round; // 四舍五入标志位 logic sign; // 符号位 logic [7:0] exp2; // 指数位 logic [23:0] val; // 有效数位 logic signed [31:0] expi; round = '0; overflow = '0; {sign, exp2, val[22:0]} = in; val[23] = 1'b1; expi = exp2 - 127 + WID_DEC; if(&exp2) // 指数位全1 overflow = 1'b1; else if(in[30:0] != 0) begin for(int i = 23; i >= 0; i--) begin if(val[i]) begin if(expi >= WID_INT + WID_DEC -1) overflow = 1'b1; else if(expi >= 0) out[expi] =1'b1; else if(ROUND && expi == -1) round = 1'b1 end expi--; end if(round) out++; end if(overflow) begin if(sign) begin out[WID_INT+WID_DEC-1] = 1'b1; out[WID_INT+WID_DEC-2:0] = '0; end else begin out[WID_INT+WID_DEC-1] = 1'b0; out[WID_INT+WID_DEC-2:0] = '1; end end else begin if(sign) out = (~out) + (WID_INT+WID_DEC)'(1); ebd end endmodule 流水线 module Float2Fix_pipe #( parameter WID_INT = 8, // 输入浮点数的整数位宽，默认=8 parameter WID_DEC = 8, // 输入浮点数的小数位宽，默认=8 parameter ROUND = 1 // 结果小数截断时，是否四舍五入，默认开启四舍五入 )( input wire [31:0] in, // 输入浮点数(IEEE 754 单精度) output reg [WID_INT+WID_DEC-1:0] out, // 输出定点数 output reg overflow // 结果是否溢出，若溢出则为 1'b1 // 若为上溢出，则out被置为最大正值 // 若为下溢出，则out被置为最小负值 ); initial {out, overflow} = '0; // input comb wire sign; wire [7:0] exp; wire [23:0] val; assign {sign, exp, val[22:0]} = in; assign val[23] = |exp; // pipeline-stage1 reg signinit = 1'b0; reg roundinit = 1'b0; reg signed [31:0] expinit = '0; reg [WID_INT+WID_DEC-1] outinit = '0; endmodule Copyright © Priself.zz@gmail.com 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-21 20:56:03 "},"blog/hardalgo/systolic-array.html":{"url":"blog/hardalgo/systolic-array.html","title":"脉动阵列(@Gemini、TPU、AIE)","keywords":"","body":" 详解脉动阵列 Reference: 《FPGA原理和结构》日 天野英晴 脉动算法 脉动算法和脉动阵列 脉动算法（systolic algorithm）是指基于 H. T. Kung 所提倡的脉动阵列（systolic array）所实现的进行并行处理的算法的总称。脉动阵列是一种由众多简单的运算元件（Processing Element，PE）按规则排列的硬件架构，具有以下特征： 由单一或多种构造 PE 按规则排列 只有相邻的 PE 互相连接，数据每次只能在局部范围内移动。 除了局部连接，同时还采用总线等连接方式的架构被称为半脉动阵列（semi-systolic array） PE 只重复进行简单的数据处理和必要的数据收发 所有 PE 由统一的时钟同步工作 每个 PE 都和相邻 PE 同步进行数据收发和运算。数据从外部流入，PE 阵列一边搬运数据，一边采用流水型或并行方式对其进行处理。各个 PE 的运算和数据收发动作和心脏规律性地收缩（systolic）促进血液流动的过程非常相似，因此此类架构被命名为脉动阵列。此外，PE 又是也被称为单元（cell） 基于一维脉动阵列的部分排序（TopK） 将 nnn 个数据组成的数组按数值从大到小排列，再输出其中数值最大的 NNN 个数据 一维排列上的 NNN 个 PE 都具有寄存器，用来保存临时最大值 XmaxX_{\\text{max}}X​max​​ 当输入 XinX_{\\text{in}}X​in​​ 比 XmaxX_{\\text{max}}X​max​​ 大时将 XmaxX_{\\text{max}}X​max​​ 更新为 XinX_{\\text{in}}X​in​​ 临时最大值更新时将原本的 XmaxX_{\\text{max}}X​max​​ 输出到右侧的 PE，没有更新时则将 XinX_{\\text{in}}X​in​​ 输出到右侧的 PE 不断重复这个过程直到最后第 NNN 个数据进入 PE 数值最大的 NNN 个数据就会从左到右按顺序存放在各个 PE 的寄存器中，采用 NNN 个 PE 组成的脉动阵列对 nnn 个数据进行部分排序，总共需要 (N+n−1)(N+n-1)(N+n−1) 个步骤。 module PE ( input wire clk; input wire rst_n; input wire mode; input wire shiftRead; input wire [7:0] Xin; input wire [7:0] Zin; output wire [7:0] Xout; output wire [7:0] Zout; ); reg [7:0] Xmax; always @(posedge clk or negedge rst_n) begin if(!rst_n) Xmax Xmax) Xmax Xmax ? Xmax : Xin; assign Zout = Xmax; endmodule 基于一维脉动阵列的矩阵-向量相乘 矩阵向量相乘运算 Y=AXY = AXY=AX 可以采用一维脉动阵列实现 运算元素数为 N×NN \\times NN×N 的矩阵所需 PE 个数为 NNN 待续... 基于二维脉动阵列的矩阵-矩阵相乘 矩阵相乘运算 C=ABC = ABC=AB 运算元素数为 N×NN \\times NN×N 的矩阵，需要 N2N^2N​2​​ 个 PE 构成的 N×NN\\times NN×N 纵横排列的脉动阵列 AI处理器的矩阵处理单元专用于专用于矩阵乘法和卷积运算 脉动阵列是用于实现矩阵处理器最为常见的微架构，它本身的数学原理其实非常简单。 为了将脉动阵列应用于不同场景（经典场景：矩阵乘法、卷积运算），理解其数据流是关键。 理解了数据流，那么微架构的设计就呼之欲出、顺理成章了。 待续... Copyright © Priself.zz@gmail.com 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 22:56:45 "}}